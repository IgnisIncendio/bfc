#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

/* Exit codes */

#define EXIT_OK						0
#define EXIT_USAGE					1
#define EXIT_ERR_SOURCEUNREADABLE	-1
#define EXIT_ERR_NOMEMORY			-2
#define EXIT_ERR_OUTPUTUNWRITABLE	-3

/* Exit error messages */

#define EXIT_ERR_SOURCEUNREADABLE_MSG	"Error -1: Source unreadable"
#define EXIT_ERR_NOMEMORY_MSG			"Error -2: No memory"
#define EXIT_ERR_OUTPUTUNWRITABLE_MSG	"Error -3: Output unwritable"

/* Modes */

#define MODE_ASSEMBLY	0
#define MODE_OBJECT		1
#define MODE_EXECUTABLE	2

#define TMP_OUTPUT_ASM	"/tmp/bfcOutput.asm"
#define TMP_OUTPUT_O	"/tmp/bfcOutput.o"

/* AST
 * 
 * Instruction table
 * --TYPE-----STRUCT-----INSTRUCTION--
 * 0	instruction			Increment pointer (>)
 * 1	instruction			Decrement pointer (<)
 * 2	instruction			Increment memory (+)
 * 3	instruction			Decrement memory (-)
 * 4	instruction			Output memory as ASCII (.)
 * 5	instruction			Input to memory as ASCII (,)
 * 6	instruction_loop	Loop ([])
 */

struct instruction {
	uint8_t type;
	void* next;
};

struct instruction_loop {
	uint8_t type;
	void* next;
	void* innerNext;
};

uint8_t modeOption(char option) {
	switch (option) {
		case 'a': return MODE_ASSEMBLY;
		case 'e': return MODE_EXECUTABLE;
		case 'o': return MODE_OBJECT;
		default: return MODE_ASSEMBLY;
	}
}

int main(int argc, char** argv) {
	
	char* buffer = malloc(1024);
	if (!buffer) {
		puts(EXIT_ERR_NOMEMORY_MSG);
		return EXIT_ERR_NOMEMORY;
	}
	
	uint8_t mode = MODE_ASSEMBLY;
	char* outputPath = "a.out";
	char* sourcePath;
	
	/* Use arguments and print usage if incorrect */
	
	if (argc == 2) {
		sourcePath = argv[1];
	}
	else if (argc == 3) {
		if (argv[1][0] == '-') {
			mode = modeOption(argv[1][1]);
			sourcePath = argv[2];
		}
		else {
			outputPath = argv[1];
			sourcePath = argv[2];
		}
	}
	else if (argc == 4) {
		if (argv[1][0] == '-') {
			mode = modeOption(argv[1][1]);
			outputPath = argv[2];
			sourcePath = argv[3];
		}
		else {
			puts("Usage: bfc [-a|e|o] [output] source");
			return EXIT_USAGE;
		}
	}
	else {
		puts("Usage: bfc [-a|e|o] [output] source");
		return EXIT_USAGE;
	}
	
	/*
	 * PARSE SOURCE
	 */
	
	/* Load source file */
	
	FILE* sourceFile = fopen(sourcePath, "r");
	if (!sourceFile) {
		puts(EXIT_ERR_SOURCEUNREADABLE_MSG);
		return EXIT_ERR_SOURCEUNREADABLE;
	}
	
	fseek(sourceFile, 0, SEEK_END);
	uint32_t sourceLength = ftell(sourceFile);
	fseek(sourceFile, 0, SEEK_SET);
	uint8_t* sourceBuffer = malloc(sourceLength);
	if (!sourceBuffer) {
		puts(EXIT_ERR_NOMEMORY_MSG);
		return EXIT_ERR_NOMEMORY;
	}
	fread(sourceBuffer, 1, sourceLength, sourceFile);
	fclose(sourceFile);
	
	/* Parse source file */
	
	/* Pointer to the first instruction */
	void* first = NULL;
	{
		/* Pointer to the variable to set with the next instruction's address */
		void** next = &first;
		
		for (uint32_t pos = 0; pos < sourceLength; pos++) {
			uint8_t sourceChar = sourceBuffer[pos];
			
			switch (sourceChar) {
				case '>':
				case '<':
				case '+':
				case '-':
				case '.':
				case ',':;
					/* Allocate memory for new instruction */
					struct instruction* current = malloc(sizeof(struct instruction));
					if (!current) {
						puts(EXIT_ERR_NOMEMORY_MSG);
						return EXIT_ERR_NOMEMORY;
					}
					
					/* Set previous instruction's next with new instruction address */
					*next = current;
					/* Next instruction address should go into this instruction's next */
					next = &(current->next);
					
					current->next = NULL;
					
					switch (sourceChar) {
						case '>':
							current->type = 0;
							break;
						case '<':
							current->type = 1;
							break;	
						case '+':
							current->type = 2;
							break;
						case '-':
							current->type = 3;
							break;
						case '.':
							current->type = 4;
							break;
						case ',':
							current->type = 5;
							break;
					}
					break;
			}
		}
	}
	
	/* Release source buffer */
	
	free(sourceBuffer);
	
	/*
	 * COMPILE FROM AST
	 */
	
	/* Open output file */
	
	FILE* outputFile = fopen((mode == MODE_ASSEMBLY) ? outputPath : TMP_OUTPUT_ASM, "w");
	if (!outputFile) {
		puts(EXIT_ERR_OUTPUTUNWRITABLE_MSG);
		return EXIT_ERR_OUTPUTUNWRITABLE;
	}
	
	/* Start output file */
	
	fputs(
		"; NASM elf_i386 Linux assembly generated by bfc\n"
		"section .bss\n"
		"memory resb 1024\n"
		"section .text\n"
		"global _start\n"
		"_start:\n"
		"mov eax, memory\n", outputFile);
		
	/* Fill output file */
	 
	void* next = first;
	
	while (next) {
		switch (((struct instruction*) next)->type) {
			case 0:
				fputs("inc eax\n", outputFile);
				break;
			case 1:
				fputs("dec eax\n", outputFile);
				break;
			case 2:
				fputs("inc byte [eax]\n", outputFile);
				break;
			case 3:
				fputs("dec byte [eax]\n", outputFile);
				break;
			case 4:
				fputs(
					"mov ecx, eax\n"
					"mov eax, 4\n"
					"mov ebx, 1\n"
					"mov edx, 1\n"
					"int 0x80\n"
					"mov eax, ecx\n", outputFile);
				break;
			case 5:
				fputs(
					"mov ecx, eax\n"
					"mov eax, 3\n"
					"mov ebx, 0\n"
					"mov edx, 1\n"
					"int 0x80\n"
					"mov eax, ecx\n", outputFile);
				break;
		}
		
		next = ((struct instruction*) next)->next;
	}
	
	/* Finish output file */
	
	fputs(
		"mov eax, 1\n"
		"mov ebx, 0\n"
		"int 0x80\n", outputFile);
	
	/* Close output file */
	
	fclose(outputFile);
	
	/* Release AST */
	
	next = first;
	
	while (next) {
		void* toBeNext = ((struct instruction*) next)->next;
		free(next);
		next = toBeNext;
	}
	
	/*
	 * GENERATE OBJECT OR EXECUTABLE
	 */
	
	switch (mode) {
		case MODE_OBJECT:
			sprintf(buffer, "nasm -felf -o%s " TMP_OUTPUT_ASM, outputPath);
			system(buffer);
			break;
		case MODE_EXECUTABLE:
			system("nasm -felf -o" TMP_OUTPUT_O " " TMP_OUTPUT_ASM);
			sprintf(buffer, "ld -melf_i386 -o%s " TMP_OUTPUT_O, outputPath);
			system(buffer);
			break;
	}
	
	/*
	 * EXIT
	 */
	
	free(buffer);
		
	return EXIT_OK;
}
